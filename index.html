<!DOCTYPE html>
<html>
<head>
    <title>Neon Jump: Star Edition</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; touch-action: none; }
        #ui-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(0,0,0,0.9); z-index: 10; text-align: center; color: #0f0; }
        #game-hud { position: absolute; top: 20px; width: 100%; display: none; justify-content: space-between; padding: 0 20px; box-sizing: border-box; z-index: 5; pointer-events: none; }
        #resetBtn { pointer-events: auto; padding: 10px; background: rgba(0,255,0,0.2); border: 1px solid #0f0; color: #0f0; border-radius: 5px; font-family: inherit; }
        .stat { color: #0f0; font-size: 1.2rem; text-shadow: 0 0 5px #0f0; }
        button#startBtn { padding: 15px 30px; font-size: 1.2rem; cursor: pointer; border: 2px solid #0f0; background: #000; color: #0f0; box-shadow: 0 0 15px #0f0; }
    </style>
</head>
<body>

    <div id="ui-overlay">
        <h1>NEON JUMP</h1>
        <p>USE HTTPS TO ENABLE SENSORS<br>TILT TO LOOK | TAP TO JUMP</p>
        <button id="startBtn">SYNC SENSORS</button>
    </div>

    <div id="game-hud">
        <div class="stat">SCORE: <span id="score">0</span></div>
        <button id="resetBtn">CALIBRATE</button>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        let scene, camera, renderer, road, material, starMat;
        let currentTiltX = 0, currentTiltY = 0, offsetX = 0, offsetY = 0;
        let hue = 0, score = 0;
        let isJumping = false, jumpVelocity = 0;
        const gravity = -0.015;
        let obstacles = [];

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 10, 60);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // 1. STARFIELD
            const starGeo = new THREE.BufferGeometry();
            const starPos = [];
            for(let i=0; i<3000; i++) {
                starPos.push((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100);
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true });
            scene.add(new THREE.Points(starGeo, starMat));

            // 2. THE ROAD
            road = new THREE.Mesh(
                new THREE.PlaneGeometry(30, 1000, 30, 100),
                new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true })
            );
            road.rotation.x = -Math.PI / 2;
            scene.add(road);

            // 3. OBSTACLES
            for(let i=0; i < 6; i++) spawnObstacle(i);

            camera.position.y = 2;
            animate();
        }

        function spawnObstacle(i) {
            const obs = new THREE.Mesh(
                new THREE.BoxGeometry(5, 2, 1),
                new THREE.MeshBasicMaterial({ color: 0xff0055, wireframe: true })
            );
            obs.position.set((Math.random()-0.5)*20, 1, -((i+1)*40));
            scene.add(obs);
            obstacles.push(obs);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Effects
            hue += 0.002;
            road.material.color.setHSL(hue % 1, 1, 0.5);
            starMat.opacity = 0.5 + Math.sin(Date.now() * 0.003) * 0.5;

            // Jump
            if (isJumping) {
                camera.position.y += jumpVelocity;
                jumpVelocity += gravity;
                if (camera.position.y <= 2) { camera.position.y = 2; isJumping = false; }
            }

            // Move World
            road.position.z += 0.6;
            if (road.position.z > 100) road.position.z = 0;

            obstacles.forEach(obs => {
                obs.position.z += 0.6;
                // Basic Collision
                const playerX = camera.rotation.y * -25; 
                if (Math.abs(obs.position.z) < 1.5 && Math.abs(obs.position.x - playerX) < 3 && camera.position.y < 3) {
                    score = 0;
                    document.getElementById('score').innerText = score;
                }
                if (obs.position.z > 10) {
                    obs.position.z = -200;
                    obs.position.x = (Math.random()-0.5)*20;
                    score++;
                    document.getElementById('score').innerText = score;
                }
            });

            // Tilt & Reset Logic
            const targetRotY = -(currentTiltX - offsetX) * 0.03;
            const targetRotX = (currentTiltY - offsetY) * 0.015;
            camera.rotation.y = THREE.MathUtils.lerp(camera.rotation.y, targetRotY, 0.1);
            camera.rotation.x = THREE.MathUtils.lerp(camera.rotation.x, targetRotX, 0.1);

            renderer.render(scene, camera);
        }

        // Start & Permissions
        document.getElementById('startBtn').addEventListener('click', async () => {
            if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const response = await DeviceOrientationEvent.requestPermission();
                    if (response === 'granted') startSensors();
                } catch (e) { alert("Permission denied"); }
            } else {
                startSensors(); // Android / Desktop
            }
        });

        function startSensors() {
            document.getElementById('ui-overlay').style.display = 'none';
            document.getElementById('game-hud').style.display = 'flex';
            window.addEventListener('deviceorientation', (e) => {
                currentTiltX = e.gamma || 0;
                currentTiltY = e.beta || 0;
            });
            init();
        }

        window.addEventListener('touchstart', () => { if(!isJumping) { isJumping = true; jumpVelocity = 0.35; } });
        document.getElementById('resetBtn').addEventListener('click', () => { offsetX = currentTiltX; offsetY = currentTiltY; });
    </script>
</body>
</html>
